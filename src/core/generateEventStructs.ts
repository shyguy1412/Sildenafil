//dont judge, this POS is just to generate the events.rs file

// deno-lint-ignore-file no-explicit-any
const SCHEMA_PATH = './ed-journal-schemas/schemas';

const schemas = Deno.readDirSync(SCHEMA_PATH)
  .map(ent => ent.isDirectory ?
    { ...Deno.readDirSync(`${SCHEMA_PATH}/${ent.name}`).toArray()[0], path: `${SCHEMA_PATH}/${ent.name}` } :
    { ...ent, path: SCHEMA_PATH })
  .map(ent => `${ent.path}/${ent.name}`)
  .map(path => ({
    path,
    content: JSON.parse(Deno.readTextFileSync(path))
  }))
  .toArray();


const commonSchema = schemas.splice(schemas.findIndex(schema => schema.path.endsWith('ShipLockerBackpack.json')), 1)[0];
const baseEventSchema = schemas.splice(schemas.findIndex(schema => schema.path.endsWith('_Event.json')), 1)[0];

const eventStructs: string[] = [];
const internalStructs: Map<string, any> = new Map();

for (const struct in commonSchema.content.definitions) {
  const schema = commonSchema.content.definitions[struct];
  internalStructs.set(struct + 'Common', schema);
}

const changeEntrySchema = schemas.find(schema => schema.content.definitions)!.content.definitions.changeEntry;

internalStructs.set("ChangeEntryCommon", changeEntrySchema);

type StructProperty = { ident: string, type: string; optional: boolean; };

for (const schema of schemas) {
  const props: StructProperty[] = [];

  const base = schema.content.extends;

  if (base && base.$ref.endsWith('_Event.json'))
    props.push(...transformSchemaToProperties(baseEventSchema.content));

  props.push(...transformSchemaToProperties(schema.content));

  const ident = schema.path.replace(/.*\/(.*?)\.json$/, '$1');

  eventStructs.push(`\
#[derive(Clone, Debug, Event)]
#[event_name("${ident}")]
#[allow(non_snake_case)]
pub struct ${ident} {${props
      .map(structPropToString)
      .reduce((prev, cur) => `${prev}\n  ${cur}`, '  ')
    }\n}`
  );
}

const imports = '//AUTOGENERATED: DO NOT EDIT MANUALLY\nuse bondage::*;\n';
const generatedEvents = eventStructs.join('\n');
const generatedStructs = internalStructs.entries().reduce((prev, [ident, schema]) => `${prev}
#[derive(Clone, Debug, Transferable)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
pub struct ${ident}Struct {\
${transformSchemaToProperties(schema)
    .map(structPropToString)
    .reduce((prev, cur) => `${prev}\n  ${cur}`, '  ')
  }
}
`, '');

const fleetCarrierEnum = `
#[derive(Clone, Debug)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
pub enum FLEETCARRIER_DISTANCE_TRAVELLEDEnum {
    Lexical(String),
    Numerical(f64),
}

impl Transferable for FLEETCARRIER_DISTANCE_TRAVELLEDEnum {
    type JsForm = JsValue;

    fn to_js<'cx>(&self, ctx: &mut Cx<'cx>) -> NeonResult<Handle<'cx, Self::JsForm>> {
        match self {
            FLEETCARRIER_DISTANCE_TRAVELLEDEnum::Lexical(val) => {
                val.to_js(ctx).map(|v| v.as_value(ctx))
            }
            FLEETCARRIER_DISTANCE_TRAVELLEDEnum::Numerical(val) => {
                val.to_js(ctx).map(|v| v.as_value(ctx))
            }
        }
    }

    fn from_js<'cx>(ctx: &mut Cx<'cx>, object: Handle<'cx, Self::JsForm>) -> NeonResult<Self>
    where
        Self: Sized,
    {
        match object.is_a::<JsNumber, _>(ctx) {
            true => Ok(Self::Numerical(object.downcast::<JsNumber, _>(ctx).unwrap().value(ctx))),
            false => object.downcast::<JsString, _>(ctx)
            .map_err(|_|ctx.throw_error::<_, &str>("INVALID CAST FLEETCARRIER_DISTANCE_TRAVELLEDEnum").unwrap_err())
            .map(|v|Self::Lexical(v.value(ctx))),
        }
    }
}
`;

const eventMap = `
#[derive(Clone, Debug)]
#[allow(non_snake_case)]
pub struct EventMap {
${schemas
    .map(schema => schema.path.replace(/.*\/(.*?)\.json$/, "$1"))
    .reduce((prev, cur) => `${prev}  ${cur}:Option<${cur}>,\n`, '')
  }
}
`;

const addedAndRemoveStructs = '';
const generatedModule = imports + eventMap + generatedEvents + generatedStructs + fleetCarrierEnum + addedAndRemoveStructs;

Deno.writeTextFileSync('./events.rs', generatedModule, { create: true });

function structPropToString(prop: StructProperty) {
  const type = prop.optional ? `Option<${prop.type}>` : prop.type;
  return `${prop.ident}: ${type},`;
}

function transformSchemaToProperties(schema: any): StructProperty[] {
  const props: StructProperty[] = [];
  for (const property in schema.properties) {
    const propertySchema = schema.properties[property];
    props.push({
      ident: property,
      optional: true,
      type: schemaPropertyToStructType(propertySchema)
    });
  }

  for (const prop of props) {
    if (schema.required?.includes(prop.ident))
      prop.optional = false;
  }

  return props;
}


function schemaPropertyToStructType(prop: any, parent_title?: string): string {

  const title = prop.title ?? parent_title;

  // if ("anyOf" in prop) return (console.warn("ENUM REQUIRED"), prop.title);

  //Fix for missing type in some props
  if (!('anyOf' in prop) && !('$ref' in prop)) prop.type ??= 'object';

  switch (prop.type) {
    case 'integer':
    case 'number':
      return 'f64';

    case 'string':
      return 'String';

    case 'boolean':
      return 'bool';

    case 'object':
      //The NavRouteClear event has items without properties since the array is always empty
      //This overwrites the RouteStruct to be empty
      //Only creating structs that actually have props prevents this
      if ("properties" in prop)
        internalStructs.set(title, prop);
      return title + "Struct";

    case 'array':
      // internalStructs.set(title, prop.items);
      //special case for BackpackChange event
      if (title == "Added" || title == "Removed") {
        return `Vec<${schemaPropertyToStructType(prop.items, "ChangeEntry")}>`;
      }
      return `Vec<${schemaPropertyToStructType(prop.items, title)}>`;

    case undefined:
      //some types have a stray trailing s
      if ("$ref" in prop)
        return title.replace(/s$/, '') + 'CommonStruct';
      else
        return title + "Enum";

    default: throw new Error(`No mapped type for '${prop.type}'`);
  }
}
